# Documentation:
## partDetection module

### General:
+ To make this module work you have to install all the project dependencies (OpenCV etc.)
+ *partDetection* is implemented as a singleton-class, so there is no need to initialize this class
+ There are a bunch of test images located in the *testImages* folder
+ Testimages generated by the module will be written into *montybot/montybot/images*

### Input:
+ In this implementation the only input is a path to a test picture on which you want to test the partDetection and a True/False statement to define if the testImages displays a part with a hole or not. For example:

    ```python
          ./partDetection.py testImages/bild13.jpg True
    ```
+ In later implementations there should be only one boolean input if the box we want to detect should have a hole in it or not (-> *boxHasHole = True/False*). *partDetection* will be accessing the camera of the Raspberry Pi directly to generate the pictures and will be called by the API.

### Output:
+ The output is a tupel which defines the **GrabPoint-Offset** relative to the center of the image (the X and Y values the robot should move in millimeters ) and an **offset-rotation** (the rotation angle the robot should turn in degrees).


### To-Do:
+ Uncomment the RaspberryPI imports and implementations and test/finish them
+ Implement a *part recognition* where you can check if you want to grab the right part by looking at the parts contours and compare them to the model vectors
+ Automate the detection of holes in a part (e.g. by implementing a hole variable in the part models and check if the value is True/False..)
+ Implement an algorithm to move the GripPoint when the GripPoint intersects with a hole in the part

## calibration module:
Calibrates the config-file with a conversion between pixel values und millimeters so the partDetection module can convert those values in it's calculations. To generate a calibration simply put a white paper with only an square on it under the camera. The square should have the same distance to the camera as the parts would have. Put the real measurements (in millimeters) of the square in the config by using the API or a text editor and call the **calibrate()** function and let the skript do its job.


## geometry module:
This module implements custom vector operations such as intersections or angle computations

## exceptions module:
This module provides custom exceptions
